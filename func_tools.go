// Package gftools provides functional utilities, including predicate (paramFunc) factories. 
// Each utility takes a function (including those generated by the predicate-factories) as argument.
package gftools

// Filter returns a new slice containing only the elements for which
// paramFunc returns true.
func Filter[T any](inputSlice []T, paramFunc func(T) bool) []T {
	var resultSlice []T
	for _, v := range inputSlice {
		if paramFunc(v) {
			resultSlice = append(resultSlice, v)
		}
	}
	return resultSlice
}

// Find returns the first element in the slice that satisfies paramFunc.
// If no match is found, the zero value of T is returned.
func Find[T any](inputSlice []T, paramFunc func(T) bool) T {
	for _, v := range inputSlice {
		if paramFunc(v) {
			return v
		}
	}
	var zeroValue T
	return zeroValue
}

// Map applies paramFunc to each element of inputSlice and returns a new slice
// containing the results as values of type any.
func Map[T any](inputSlice []T, paramFunc func(T) any) []any {
	var resultSlice []any
	for _, v := range inputSlice {
		resultSlice = append(resultSlice, paramFunc(v))
	}
	return resultSlice
}

// Some returns true if any element of inputSlice satisfies paramFunc.
func Some[T any](inputSlice []T, paramFunc func(T) bool) bool {
	for _, v := range inputSlice {
		if paramFunc(v) {
			return true
		}
	}
	return false
}

// Every returns true if all elements of inputSlice satisfy paramFunc.
func Every[T any](inputSlice []T, paramFunc func(T) bool) bool {
	for _, v := range inputSlice {
		if !paramFunc(v) {
			return false
		}
	}
	return true
}

// Reduce reduces the elements of inputSlice into a single accumulated value
// using the reducer function and an initial accumulator value.
func Reduce[T any, U any](inputSlice []T, initial U, reducer func(U, T) U) U {
	acc := initial
	for _, v := range inputSlice {
		acc = reducer(acc, v)
	}
	return acc
}

// IndexOf returns the index of the first occurrence of item in inputSlice.
// If item is not found, it returns -1.
func IndexOf[T comparable](inputSlice []T, item T) int {
	for i, v := range inputSlice {
		if v == item {
			return i
		}
	}
	return -1
}

// FindIndex returns the index of the first element in inputSlice for which
// paramFunc returns true. If no such element exists, it returns -1.
func FindIndex[T any](inputSlice []T, paramFunc func(T) bool) int {
	for i, v := range inputSlice {
		if paramFunc(v) {
			return i
		}
	}
	return -1
}

// Reverse returns a new slice with the elements of the input slice in reverse order.
func Reverse[T any](input []T) []T {
	result := make([]T, len(input))
	copy(result, input)
	for i := 0; i < len(result)/2; i++ {
		j := len(result) - i - 1
		result[i], result[j] = result[j], result[i]
	}
	return result
}
